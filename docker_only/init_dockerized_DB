#!/bin/bash

usage() {
    ME=$(basename $0)
    cat <<EOF
$ME
    initializes a dockerized DB

SYNOPSIS
    $ME <config-file> -sb | -nb | -b=<biz.conf>

DESCRIPTION
    Reads <config-file> to get information about DB-configuration. The name of
    config-file is used as part of the ID of the container to be reseted: <ID>_db.

    Arguments:
    -sb | -nb | -b=<biz.conf>
      Passed to script reset_test_data.sh
      -nb: skipp business configuration
      -sb: use "test data dump" business onfiguration
      -b=<biz.conf> directory location of business configuration
EOF
}

# $1 is name of the config-file
# check $1
CONFIG_FILE=$1
shift

RESET_TEST_DATA_ARGS=

for OPT in "$@"; do
    case $OPT in
        -sb)
            RESET_TEST_DATA_ARGS=-sb
            shift
            ;;
        -nb)
            RESET_TEST_DATA_ARGS=-nb
            shift
            ;;
        -b=*)
            RESET_TEST_DATA_ARGS="-b ${OPT#*=}"
            shift
            ;;
        -h)
            usage
            exit
            ;;
        *)  echo "invalid option $OPT" 1>&2
            echo 1>&2
            usage 1>&2
            exit 1
            ;;
    esac
done

# check parameters
if [ -z "$RESET_TEST_DATA_ARGS" ]; then
    usage 1>&2
    exit 1
fi

# returns value of requested property from cluster.properties
clusterProperty() {
    PROPERTIES_FILE="$1/cluster.properties"

    # get line containing the requested property:
    # ignore property name inside comments
    # quote all regex special chars in property name
    # if more than one line was found, last wins
    PROP_QUOTED=$(echo "$2" | sed -e 's/\./\\./g')
    LINE=$(grep "^[ \t]*/system-property=$PROP_QUOTED[ \t]*:" "$PROPERTIES_FILE" | tail -n 1)

    # extract value from line
    echo "$LINE" | sed -e 's/^[^:]*:[ \t]*"\([^"]*\).*/\1/g'
}


# check config-file
if [ -z "$CONFIG_FILE" -o ! -f "$CONFIG_FILE" ]; then
    echo "config-file missing!" 1>&2
    echo 1>&2
    usage 1>&2
    exit 1
fi

# check syntax of $CONFIG_FILE
if ! ( set -e; . $CONFIG_FILE ); then
    echo "error reading '$CONFIG_FILE'" 1>&2
    exit 1
fi

# read $CONFIG_FILE
. $CONFIG_FILE

# check properties
if [ -z "$ETC_DIR" -o ! -d "$ETC_DIR" ]; then
    echo "ETC_DIR is not a valid directory: '$ETC_DIR'" 1>&2
    exit 1
elif [ -z "$LOG_DIR" -o ! -d "$LOG_DIR" ]; then
    echo "LOG_DIR is not a valid directory: '$LOG_DIR'" 1>&2
    exit 1
elif [ -z "$SRC_DIR" -o ! -d "$SRC_DIR" ]; then
    echo "SRC_DIR is not a valid directory: '$SRC_DIR'" 1>&2
    exit 1
elif [ -z "$APP_DIR" -o ! -d "$APP_DIR" ]; then
    echo "APP_DIR is not a valid directory: '$APP_DIR'" 1>&2
    exit 1
elif [ ! -z "$PGDATA_DIR" -a ! -d "$PGDATA_DIR" ]; then
    echo "PGDATA_DIR is not a valid directory: '$PGDATA_DIR'" 1>&2
    exit 1
elif [ -z "$DUMP" -o ! -f "$SRC_DIR/postgres/dumps/$DUMP" ]; then
    echo "DUMP is not a valid file in $SRC_DIR/postgres/dumps: '$DUMP'" 1>&2
    exit 1
elif [ -z "$PG_IMAGE" ]; then
    echo "PG_IMAGE must not be empty" 1>&2
    exit 1
elif [ -z "IOM_IMAGE" ]; then
    echo "IOM_IMAGE must not be empty" 1>&2
    exit 1
fi

ID=$(basename $CONFIG_FILE)

# read db-configuration from cluster.properties
POSTGRES_DB=$(clusterProperty "$ETC_DIR" "is.oms.db.name")
POSTGRES_USER=$(clusterProperty "$ETC_DIR" "is.oms.db.user")

set -x
docker exec ${ID}_db \
       bash -c "cd /tmp/src/postgres/dumps && \
                bash reset_test_data.sh -U $POSTGRES_USER -d $POSTGRES_DB -f $DUMP -c en_US.utf8 -n $RESET_TEST_DATA_ARGS"
