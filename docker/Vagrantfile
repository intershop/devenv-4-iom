# -*- mode: ruby -*-
# vi: set ft=ruby

# Require modules
require 'json'
require 'yaml'
require 'socket'

# disable parallellism so that the containers come up in order
ENV['VAGRANT_NO_PARALLEL'] = "1"

# global configuration for the docker host
DOCKER_HOST_NAME = "iomdev"
DOCKER_HOST_VAGRANTFILE = "../Vagrantfile"

VAGRANT_ROOT = File.dirname(File.expand_path(__FILE__))

PORT_OFFSET = 10

# Read environment details from either yml or json file

configuration_file = File.join(VAGRANT_ROOT, '../environments.yml')

if File.file?(configuration_file)
  environments = YAML.load_file(configuration_file)
  # print "'" + configuration_file + "' configuration will be used."
else
  configuration_file = File.join(VAGRANT_ROOT, '../environments.json')
  environments = JSON.parse(File.read(configuration_file))
  # print "'" + configuration_file + "' configuration will be used."
end

# add required variables
environments.each.with_index(1) do |environment , index|

  environment['oms_etc_dir'] = "/tmp/#{environment['id']}/etc"
  environment['oms_var_dir'] = "/tmp/#{environment['id']}/var"
  environment['oms_app_dir'] = "/tmp/#{environment['id']}/app"
  environment['oms_src_dir'] = "/tmp/#{environment['id']}/src"

  docker_image_version = environment['docker_image'][/\d+\.\d+\.\d+\.\d+/x]
  environment['docker_image_version'] = docker_image_version

  # set default timezone
  unless environment['timezone']
    environment['timezone'] = "Europe/Berlin"
  end

end

# get the IP and hostname

# def my_first_private_ipv4
#   Socket.ip_address_list.detect{|intf| intf.ipv4_private?}
# end
#
# def my_first_public_ipv4
#   Socket.ip_address_list.detect{|intf| intf.ipv4? and !intf.ipv4_loopback? and !intf.ipv4_multicast? and !intf.ipv4_private?}
# end
#
# ip = my_first_private_ipv4.ip_address unless my_first_private_ipv4.nil?

Vagrant.configure(2) do |config|

  ###
  # provide the postgres data containers
  ###
  environments.each.with_index(1) do |environment , index|

    # provide postgres data containers
    config.vm.define "#{environment['id']}_db_data", autostart: false do |container|

      container.vm.provider "docker" do |d|

        # a host VM will be spun up even if the computer running Vagrant supports Linux containers
        d.force_host_vm = true

        # configure the docker config
        d.image = "busybox"
        d.remains_running = false

        volumes = [
          # configure the path for the postgres data
          "/var/lib/postgresql/data"
        ]

        ### file synchronization
        d.volumes = volumes

        d.name = "#{environment['id']}_db_data"
        d.pull = true

        # configure a dedicated docker host
        d.vagrant_machine = "#{DOCKER_HOST_NAME}"
        d.vagrant_vagrantfile = "#{DOCKER_HOST_VAGRANTFILE}"
      end

    end
  end

  ###
  # provide the postgres containers
  ###
  environments.each.with_index(1) do |environment , index|

    # defaults
    oms_db_name = "oms_db"
    oms_db_user = "oms_user"
    oms_db_password = "OmsDB"

    oms_db_dump = ""

    oms_skip_business_config = " -sb"

    # override defaults
    if environment['oms_db_name']
      oms_db_name = "#{environment['oms_db_name']}"
    end

    if environment['oms_db_user']
      oms_db_user = "#{environment['oms_db_user']}"
    end

    if environment['oms_db_password']
      oms_db_password = "#{environment['oms_db_password']}"
    end

    if environment['oms_db_dump']
      oms_db_dump = " -f #{environment['oms_db_dump']}"
    end

    if environment['oms_skip_business_config']
      oms_skip_business_config = " -nb"
    end

    # provide postgres data containers
    config.vm.define "#{environment['id']}_db", autostart: false do |container|

      container.vm.provider "docker" do |d|

        # a host VM will be spun up even if the computer running Vagrant supports Linux containers
        d.force_host_vm = true

        # configure the docker config
        d.image = "#{environment['docker_db_image']}"
        d.create_args = ["--volumes-from=#{environment['id']}_db_data"]
        d.remains_running = true

        # [host port:container port]
        d.ports = [
          # database port
          "#{5432 + (index * PORT_OFFSET)}:5432"
        ]

        volumes = [
          # configure the log path
          "#{environment['oms_var_dir']}/log:/tmp/pg_log"
        ]

        # configure the src path
        if environment['oms_src']
          volumes.push("#{environment['oms_src_dir']}:/tmp/src")
        end

        ### file synchronization
        d.volumes = volumes

        env = {
          POSTGRES_DB: "#{oms_db_name}",
          POSTGRES_USER: "#{oms_db_user}",
          POSTGRES_PASSWORD: "#{oms_db_password}"
        }

        d.env = env

        d.cmd = [
          "postgres",
          ### please see posgres.conf for further configurations
          "-c", "log_directory=/tmp/pg_log",
          "-c", "logging_collector=on",
          "-c", "log_destination=stderr,csvlog",
          "-c", "log_filename=pg-VM-%Y%m%d_%H%M.log",
          "-c", "log_rotation_age=1h",
          "-c", "log_min_duration_statement=200",
          "-c", "max_prepared_transactions=100",
          "-c", "timezone=#{environment['timezone']}"
        ]

        d.name = "#{environment['id']}_db"
        d.pull = true

        # configure a dedicated docker host
        d.vagrant_machine = "#{DOCKER_HOST_NAME}"
        d.vagrant_vagrantfile = "#{DOCKER_HOST_VAGRANTFILE}"
      end

    end
  end

  ###
  # provide the IOM containers
  ###
  environments.each.with_index(1) do |environment , index|

    config.vm.define "#{environment['id']}", autostart: false do |container|

      container.vm.provider "docker" do |d|

        # a host VM will be spun up even if the computer running Vagrant supports Linux containers
        d.force_host_vm = true

        # configure the docker config
        d.image = "#{environment['docker_image']}"
        d.create_args = ["--privileged"] #, "--entrypoint", "/usr/local/bin/docker_entrypoint.sh"]
        d.remains_running = true
        # [host port:container port]

        ports = [
          # OMT
          "#{8080 + (index * PORT_OFFSET)}:8080",
          # wildfly console
          "#{9990 + (index * PORT_OFFSET)}:9990",
          # debug port
          "#{8787 + (index * PORT_OFFSET)}:8787",
          # ftp port (can not be used for multiple enironments)
          # "#{21 + (index * PORT_OFFSET)}:21"
        ]

        # "30000-30009:30000-30009"
        # does not work poperly
        #  (can not be used for multiple enironments)
        # (30000..30009).each do |p|
        #   ports.push("#{p}:#{p}")
        # end

        d.ports = ports

        volumes = [
          # configure the etc path
          "#{environment['oms_etc_dir']}:/etc/opt/oms.standalone",
        ]

        # IOM-7183
        # available for images >= 2.1.11.0, 2.2.3.0, 2.3.0.0
        if (Gem::Version.new("#{environment['docker_image_version']}") >= Gem::Version.new('2.1.11.0') &&
              Gem::Version.new("#{environment['docker_image_version']}") < Gem::Version.new('2.2.0.0')) ||
           (Gem::Version.new("#{environment['docker_image_version']}") >= Gem::Version.new('2.2.3.0') &&
              Gem::Version.new("#{environment['docker_image_version']}") < Gem::Version.new('2.3.0.0')) ||
           (Gem::Version.new("#{environment['docker_image_version']}") >= Gem::Version.new('2.3.0.0'))

          # configure the var path
          volumes.push("#{environment['oms_var_dir']}:/var/opt/oms.standalone/")
        else
          # configure the log path
          volumes.push("#{environment['oms_var_dir']}/log:/var/opt/oms.standalone/log")
        end

        # configure the app path
        if environment['oms_app']
          volumes.push("#{environment['oms_app_dir']}:/opt/oms.standalone/application")
        end

        ### file synchronization
        d.volumes = volumes

        d.name = "#{environment['id']}"
        d.pull = true

        d.link("#{environment['id']}_db:postgres")

        # configure a dedicated docker host
        d.vagrant_machine = "#{DOCKER_HOST_NAME}"
        d.vagrant_vagrantfile = "#{DOCKER_HOST_VAGRANTFILE}"
      end

      html_docu = File.join(environment['path'], 'index.html')

      message = ""
      message << "You can find the documentation for your '#{environment['id']}' environment here:\n"
      message << "#{html_docu} \n"

      container.vm.post_up_message = message

      printf "\n\n\n\033[31mPLEASE NOTICE:\n\nThe vargrant variant is deprecated. It will continue to function, but we would suggest not to use it anymore. Instead, you can use the variant documented in #{html_docu}.\033[0m\n\n\n"

    end
  end

  ###
  # provide a private docker registry
  ###
  config.vm.define "registry", autostart: false do |container|

    container.vm.provider "docker" do |d|

      # configure the docker config
      d.image = "registry"
      d.remains_running = true
      # [host port:container port]
      d.ports = ['5000:5000']
      d.name = 'registry'

      # configure a dedicated docker host
      d.vagrant_machine = "#{DOCKER_HOST_NAME}"
      d.vagrant_vagrantfile = "#{DOCKER_HOST_VAGRANTFILE}"
    end
  end

end
