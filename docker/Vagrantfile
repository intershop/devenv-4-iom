# -*- mode: ruby -*-
# vi: set ft=ruby

# Require modules
require 'json'
require 'yaml'
require 'socket'

# disable parallellism so that the containers come up in order
ENV['VAGRANT_NO_PARALLEL'] = "1"

# global configuration for the docker host
DOCKER_HOST_NAME = "iomdev"
DOCKER_HOST_VAGRANTFILE = "../Vagrantfile"

VAGRANT_ROOT = File.dirname(File.expand_path(__FILE__))

PORT_OFFSET = 10

# Read environment details from either yml or json file

configuration_file = File.join(VAGRANT_ROOT, '../environments.yml')

if File.file?(configuration_file)
  environments = YAML.load_file(configuration_file)
  # print "'" + configuration_file + "' configuration will be used."
else
  configuration_file = File.join(VAGRANT_ROOT, '../environments.json')
  environments = JSON.parse(File.read(configuration_file))
  # print "'" + configuration_file + "' configuration will be used."
end

# get the IP and hostname

# def my_first_private_ipv4
#   Socket.ip_address_list.detect{|intf| intf.ipv4_private?}
# end
#
# def my_first_public_ipv4
#   Socket.ip_address_list.detect{|intf| intf.ipv4? and !intf.ipv4_loopback? and !intf.ipv4_multicast? and !intf.ipv4_private?}
# end
#
# ip = my_first_private_ipv4.ip_address unless my_first_private_ipv4.nil?

Vagrant.configure(2) do |config|

  ###
  # provide the postgres data containers
  ###
  environments.each.with_index(1) do |environment , index|

    # provide postgres data containers
    config.vm.define "#{environment['id']}_db_data", autostart: false do |container|

      container.vm.provider "docker" do |d|

        # a host VM will be spun up even if the computer running Vagrant supports Linux containers
        d.force_host_vm = true

        # configure the docker config
        d.image = "busybox"
        d.remains_running = false

        volumes = [
          # configure the path for the postgres data
          "/var/lib/postgresql/data"
        ]

        ### file synchronization
        d.volumes = volumes

        d.name = "#{environment['id']}_db_data"
        d.pull = true

        # configure a dedicated docker host
        d.vagrant_machine = "#{DOCKER_HOST_NAME}"
        d.vagrant_vagrantfile = "#{DOCKER_HOST_VAGRANTFILE}"
      end

    end
  end

  ###
  # provide the postgres containers
  ###
  environments.each.with_index(1) do |environment , index|

    # defaults
    oms_db_name = "oms_db"
    oms_db_user = "oms_user"
    oms_db_password = "OmsDB"

    oms_db_dump = ""

    oms_skip_business_config = " -sb"

    # override defaults
    if environment['oms_db_name']
      oms_db_name = "#{environment['oms_db_name']}"
    end

    if environment['oms_db_user']
      oms_db_user = "#{environment['oms_db_user']}"
    end

    if environment['oms_db_password']
      oms_db_password = "#{environment['oms_db_password']}"
    end

    if environment['oms_db_dump']
      oms_db_dump = " -f #{environment['oms_db_dump']}"
    end

    if environment['oms_skip_business_config']
      oms_skip_business_config = " -nb"
    end

    # provide postgres data containers
    config.vm.define "#{environment['id']}_db", autostart: false do |container|

      container.vm.provider "docker" do |d|

        # a host VM will be spun up even if the computer running Vagrant supports Linux containers
        d.force_host_vm = true

        # configure the docker config
        d.image = "#{environment['docker_db_image']}"
        d.create_args = ["--volumes-from=#{environment['id']}_db_data"]
        d.remains_running = true

        # [host port:container port]
        d.ports = [
          # database port
          "#{5432 + (index * PORT_OFFSET)}:5432"
        ]

        volumes = [
          # configure the log path
          "/tmp/#{environment['id']}/log/pg_log:/tmp/pg_log"
        ]

        # configure the src path
        if environment['oms_src']
          volumes.push("/tmp/#{environment['id']}/src:/tmp/src")
        end

        ### file synchronization
        d.volumes = volumes

        env = {
          POSTGRES_DB: "#{oms_db_name}",
          POSTGRES_USER: "#{oms_db_user}",
          POSTGRES_PASSWORD: "#{oms_db_password}"
        }

        d.env = env

        d.cmd = [
          "postgres",
          "-c", "log_directory=/tmp/pg_log"
          ### please see posgres.conf for further configurations
          # ,
          # "-c", "logging_collector=on",
          # "-c", "log_destination=stderr",
          # "-c", "log_statement=all",
          # "-c", "log_min_error_statement=info"
        ]

        d.name = "#{environment['id']}_db"
        d.pull = true

        # configure a dedicated docker host
        d.vagrant_machine = "#{DOCKER_HOST_NAME}"
        d.vagrant_vagrantfile = "#{DOCKER_HOST_VAGRANTFILE}"
      end

      message = "\n"
      message << "Your postgres container '#{environment['id']}_db' requires an initialization. \n"
      message << "Login into your docker host and run following command:\n\n"
      message << "docker exec #{environment['id']}_db bash -c 'cd /tmp/src/postgres/dumps && \\\n"
      message << "bash reset_test_data.sh -U #{oms_db_user} -d #{oms_db_name}#{oms_db_dump}#{oms_skip_business_config} -c en_US.utf8 -n'\n\n"
      message << "Your postgres container '#{environment['id']}_db' is accessible from your host system with following connection data:\n\n"
      message << "host:\t\tlocalhost\n"
      message << "port:\t\t#{5432 + (index * PORT_OFFSET)}\n"
      message << "name:\t\t#{oms_db_name}\n"
      message << "user:\t\t#{oms_db_user}\n"
      message << "password:\t#{oms_db_password}\n\n"
      message << "In order to use the postgres container '#{environment['id']}_db' for your IOM container '#{environment['id']}' \n"
      message << "please set following connection data in your cluster.properties:\n\n"
      message << "/system-property=is.oms.db.hostlist: \"postgres:5432\"\n"
      message << "/system-property=is.oms.db.name: \"#{oms_db_name}\"\n"
      message << "/system-property=is.oms.db.user: \"#{oms_db_user}\"\n"
      message << "/system-property=is.oms.db.pass: \"#{oms_db_password}\"\n\n"

      container.vm.post_up_message = message

    end
  end

  ###
  # provide the IOM containers
  ###
  environments.each.with_index(1) do |environment , index|

    config.vm.define "#{environment['id']}", autostart: false do |container|

      container.vm.provider "docker" do |d|

        # a host VM will be spun up even if the computer running Vagrant supports Linux containers
        d.force_host_vm = true

        # configure the docker config
        d.image = "#{environment['docker_image']}"
        d.create_args = ["--privileged"]
        d.remains_running = true
        # [host port:container port]

        ports = [
          # OMT
          "#{8080 + (index * PORT_OFFSET)}:8080",
          # wildfly console
          "#{9990 + (index * PORT_OFFSET)}:9990",
          # debug port
          "#{8787 + (index * PORT_OFFSET)}:8787",
          # ftp port
          "#{21 + (index * PORT_OFFSET)}:21"
        ]

        # "30000-30009:30000-30009"
        # does not work poperly
        (30000..30009).each do |p|
          ports.push("#{p}:#{p}")
        end

        d.ports = ports

        volumes = [
          # configure the etc path
          "/tmp/#{environment['id']}/etc:/etc/opt/oms.standalone",

          # configure the log path
          "/tmp/#{environment['id']}/log:/var/opt/oms.standalone/log"
        ]

        # configure the app path
        if environment['oms_app']
          volumes.push("/tmp/#{environment['id']}/app:/opt/oms.standalone/application")
        end

        ### file synchronization
        d.volumes = volumes

        d.name = "#{environment['id']}"
        d.pull = true

        d.link("#{environment['id']}_db:postgres")

        # configure a dedicated docker host
        d.vagrant_machine = "#{DOCKER_HOST_NAME}"
        d.vagrant_vagrantfile = "#{DOCKER_HOST_VAGRANTFILE}"
      end

      message = "\n"
      message << "Your IOM container '#{environment['id']}' requires a reconfiguration. \n"
      message << "Login into your docker host and run following command:\n\n"
      message << "docker exec #{environment['id']} bash /usr/local/bin/docker_reconfigure.sh --wsdl-host=#{Socket.gethostname} --wsdl-port=#{8080 + (index * PORT_OFFSET)}\n\n"
      message << "Visit http://localhost:#{8080 + (index * PORT_OFFSET)}/omt (resp. /bakery.omt) for the OMT application! \n"
      message << "Visit http://localhost:#{9990 + (index * PORT_OFFSET)}/console for the wildfly console.\n"
      message << "Use port #{8787 + (index * PORT_OFFSET)} for debugging purposes.\n"
      # message << "Use localhost:#{21 + (index * PORT_OFFSET)} to connect via FTP.\n\n"

      container.vm.post_up_message = message

    end
  end

  ###
  # provide a private docker registry
  ###
  config.vm.define "registry", autostart: false do |container|

    container.vm.provider "docker" do |d|

      # configure the docker config
      d.image = "registry"
      d.remains_running = true
      # [host port:container port]
      d.ports = ['5000:5000']
      d.name = 'registry'

      # configure a dedicated docker host
      d.vagrant_machine = "#{DOCKER_HOST_NAME}"
      d.vagrant_vagrantfile = "#{DOCKER_HOST_VAGRANTFILE}"
    end
  end

end
