<html>
  <head>
    <title>${ID} IOM development environment</title>

    <!--meta http-equiv="refresh" content="60"-->

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <!-- google code-prettify -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

    <!-- font awesome -->
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- https://github.com/daylerees/colour-schemes -->
    <style>

      body > .container {
        margin-top: 50px;
      }

      .alias-toggle {
        padding: 2px 3px;
      }

    </style>

  </head>
  <body>
    <!-- Fixed navbar -->
      <nav class="navbar navbar-default navbar-fixed-top">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="#">${ID}</a>
          </div>
          <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Configurations <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  <li><a href="#configurations--database-connection-properties">Database connection properties</a></li>
                  <li><a href="#configurations--automatic-port-forwarding">Automatic port forwarding</a></li>
                </ul>
              </li>
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Operations <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  <li><a href="#operations--setup-environment">Setup the whole IOM environment</a></li>
                  <li><a href="#operations--remove-environment">Remove the whole IOM environment</a></li>
                  <li><a href="#operations--create-namespace">Create namespace</a></li>
                  <li><a href="#operations--remove-namespace">Remove namespace</a></li>
                  <li><a href="#operations--start-mailserver">Start mailserver</a></li>
                  <li><a href="#operations--remove-mailserver">Stop/remove mailserver</a></li>
                  ${KeepDatabaseDocuStart}
                  <li><a href="#operations--create-docker-volume">Create local Docker volume</a></li>
                  <li><a href="#operations--remove-docker-volume">Remove local Docker volume</a></li>
                  <li><a href="#operations--link-volume-to-db">Link Docker volume to database storage</a></li>
                  <li><a href="#operations--unlink-volume-from-db">Unlink Docker volume from database storage</a></li>
                  ${KeepDatabaseDocuEnd}
                  <li><a href="#operations--start-database">Start postgres database</a></li>
                  <li><a href="#operations--remove-database">Stop/remove postgres database</a></li>
                  <li><a href="#operations--start-iom">Start IOM</a></li>
                  <li><a href="#operations--remove-iom">Stop/remove IOM</a></li>
                </ul>
              </li>
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Development process <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  <li><a href="#development--deployment-gui">Deployment using the Wildfly Admin Console</a></li>
                  <li><a href="#development--deployment-cli">Deployment using Scripts</a></li>
                  <li><a href="#development--roll-out-mail-templates">Roll out mail templates</a></li>
                  <li><a href="#development--roll-out-xsl-templates">Roll out xsl templates</a></li>
                  <li><a href="#development--apply-sql">Apply sql scripts</a></li>
                  <li><a href="#development--apply-dbmigrate">Apply dbmigrate scripts</a></li>
                  <li><a href="#development--apply-sqlconfig">Apply sql configuration scripts</a></li>
                  <li><a href="#development--apply-jsonconfig">Apply json configuration scripts</a></li>
                  <li><a href="#development--access-emails">Access E-Mails</a></li>
                  <li><a href="#development--debugging">Debugging</a></li>
                  <li><a href="#development--testing">Testing</a></li>
                </ul>
              </li>
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Database <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  <li><a href="#database--init">Initialize the database</a></li>
                  <li><a href="#database--create-dump">Create a database dump</a></li>
                  <li><a href="#database--open-psql-terminal">Open psql terminal</a></li>
                </ul>
              </li>
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Kubernetes <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  <li><a href="#kubernetes--useful">Useful Kubernetes commands</a></li>
                </ul>
              </li>
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Troubleshooting <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  <li><a href="#troubleshooting--shared-drives">Shared Drives</a></li>
                </ul>
              </li>
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Links <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  <li><a href="http://${HOST_IOM}:${FORWARD_PORT_IOM}/omt" target="_blank">OMT</a></li>
                  <li><a href="http://${HOST_IOM}:${FORWARD_PORT_IOM}/dbdoc/" target="_blank">DB Documentation</a></li>
                  <li><a href="http://${HOST_IOM}:${FORWARD_PORT_IOM}/omt-help/" target="_blank">Online Help</a></li>
                  <li><a href="http://${HOST_IOM}:${FORWARD_PORT_WILDFLY}/console" target="_blank">WildFly console</a></li>
                  <li><a href="http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=${EnvId}" target="_blank">Kubernetes Dashboard</a></li>
                  <li><a href="http://${HOST_IOM}:${FORWARD_PORT_MAILHOG_UI}" target="_blank">Mails (Web-UI)</a></li>
                  <li><a href="http://${HOST_IOM}:${FORWARD_PORT_MAILHOG_UI}/api/v2/messages" target="_blank">Mails (REST)</a></li>
                </ul>
              </li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </nav>

      <div class="container">






        <h1>${ID} IOM development environment</h1>
        <h2 id="configurations">Configurations</h2>

        <h3 id="configurations--database-connection-properties">Database connection properties</h3>
        <p>Your postgres container is accessible from your host system (e.g. with pgAdmin) with following connection properties:</p>
        <table class="table table-striped table-condensed">
          <thead>
            <tr>
              <th>#</th>
              <th>Property</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th scope="row">1</th>
              <td>Host</td>
              <td>${HOST_IOM}</td>
            </tr>
            <tr>
              <th scope="row">2</th>
              <td>Port</td>
              <td>${FORWARD_PORT_DB}</td>
            </tr>
            <tr>
              <th scope="row">3</th>
              <td>Name</td>
              <td>${DB_NAME}</td>
            </tr>
            <tr>
              <th scope="row">4</th>
              <td>User</td>
              <td>${DB_USER}</td>
            </tr>
            <tr>
              <th scope="row">5</th>
              <td>Password</td>
              <td>${DB_PASSWORD}</td>
            </tr>
          </tbody>
        </table>

        <h3 id="configurations--automatic-port-forwarding">Automatic port forwarding</h3>
        <p>Behind the scenes port forwarding is handled automatically.</p>

        <table class="table table-striped table-condensed">
          <thead>
            <tr>
              <th>#</th>
              <th>Developer host</th>
              <th>Kubernetes Service</th>
              <th>Container</th>
              <th>Usage</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th scope="row">1</th>
              <td>${FORWARD_PORT_IOM}</td>
              <td>${FORWARD_PORT_IOM}</td>
              <td>${PORT_IOM}</td>
              <td>OMT</td>
            </tr>
            <tr>
              <th scope="row">2</th>
              <td>${FORWARD_PORT_DEBUG}</td>
              <td>${FORWARD_PORT_DEBUG}</td>
              <td>${PORT_DEBUG}</td>
              <td>Debug Port</td>
            </tr>
            <tr>
              <th scope="row">3</th>
              <td>${FORWARD_PORT_WILDFLY}</td>
              <td>${FORWARD_PORT_WILDFLY}</td>
              <td>${PORT_WILDFLY}</td>
              <td>WildFly Console (admin:admin)</td>
            </tr>
            <tr>
              <th scope="row">4</th>
              <td>${FORWARD_PORT_DB}</td>
              <td>${FORWARD_PORT_DB}</td>
              <td>${PORT_DB}</td>
              <td>PostgreSQL Database</td>
            </tr>
            <tr>
              <th scope="row">5</th>
              <td>${FORWARD_PORT_MAILHOG_SMTP}</td>
              <td>${FORWARD_PORT_MAILHOG_SMTP}</td>
              <td>${PORT_MAILHOG_SMTP}</td>
              <td>Send emails over SMTP protocol</td>
            </tr>
          </tbody>
        </table>

        <h2 id="setup">Operations</h2>

        <h3 id="operations--setup-environment">Setup the whole IOM environment</h3>

        <p>Setup of the whole IOM development environment consists of several steps. These are:</p>
        <ol>
          <li><a href="#operations--create-namespace">Create namespace</a></li>
          <li><a href="#operations--start-mailserver">Start mailserver</a></li>
          ${KeepDatabaseDocuStart}
          <li><a href="#operations--create-docker-volume">Create local Docker volume</a></li>
          <li><a href="#operations--link-volume-to-db">Link Docker volume to database storage</a></li>
          ${KeepDatabaseDocuEnd}
          <li><a href="#operations--start-database">Start postgres database</a></li>
          <li><a href="#operations--start-iom">Start IOM</a></li>
        </ol>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Create namespace
kubectl create namespace ${EnvId} 

# Start mailserver
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/mailhog.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl apply --namespace ${EnvId} -f -
${KeepDatabaseDocuStart}
# Create local Docker volume
docker volume create --name=${EnvId}-pgdata -d local

# Link Docker volume to database storage
MOUNTPOINT="\"$(docker volume inspect --format='{{.Mountpoint}}' ${EnvId}-pgdata)\"" "${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/postgres-storage.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl apply --namespace ${EnvId} -f -
${KeepDatabaseDocuEnd}
# Start postgres database
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/postgres.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl apply --namespace ${EnvId} -f -

# Start IOM
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/iom.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl apply --namespace ${EnvId} -f -
        </div></code></pre>

        <h3 id="operations--remove-environment">Remove the whole IOM environment</h3>

        <p>Removing the whole IOM development environment consists of several steps. These are:</p>
        <ol>
          <li><a href="#operations--remove-iom">Stop/remove IOM</a></li>
          <li><a href="#operations--remove-database">Stop/remove postgres database</a></li>
          ${KeepDatabaseDocuStart}
          <li><a href="#operations--unlink-volume-from-db">Unlink Docker volume from database storage</a></li>
          ${KeepDatabaseDocuEnd}
          <li><a href="#operations--remove-mailserver">Stop/remove mailserver</a></li>
          <li><a href="#operations--remove-namespace">Remove namespace</a></li>
          ${KeepDatabaseDocuStart}
          <li><a href="#operations--remove-docker-volume">Remove local Docker volume</a></li>
          ${KeepDatabaseDocuEnd}
        </ol>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Stop/Remove IOM
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/iom.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl delete --namespace ${EnvId} -f -

# Stop/Remove postgres database
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/postgres.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl delete --namespace ${EnvId} -f -
${KeepDatabaseDocuStart}
# Unlink Docker volume from database storage
MOUNTPOINT="\"$(docker volume inspect --format='{{.Mountpoint}}' ${EnvId}-pgdata)\"" "${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/postgres-storage.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl delete --namespace ${EnvId} -f -
${KeepDatabaseDocuEnd}
# Stop/Remove mailserver
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/mailhog.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl delete --namespace ${EnvId} -f -
              
# Remove namespace
kubectl delete namespace ${EnvId}
        </div></code></pre>
        ${KeepDatabaseDocuStart}
        <div class="alert alert-warning" role="alert">
          <strong>Note!</strong>
          <p>If you would like to remove the database data, you just have to remove the database data volume with the following command.</p><br>
          
          <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Remove local Docker volume
docker volume rm ${EnvId}-pgdata
          </div></code></pre>
        </div>
        ${KeepDatabaseDocuEnd}

        <!--
            ############# Operational commands ###############
          -->
        <h3 id="operations--create-namespace">Create namespace</h3>
        <p>Namespace is required, if you want to run different installations in parallel. The following command creates a namespace, based on the ID you have specified in your properties.</p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Create namespace
kubectl create namespace ${EnvId} 
        </div></code></pre>

        <h3 id="operations--remove-namespace">Remove namespace</h3>
        <p>The following command removes the namespace.</p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Remove namespace
kubectl delete namespace ${EnvId}
        </div></code></pre>

        <h3 id="operations--start-mailserver">Start mailserver</h3>
        <p>The following command creates a mailserver, that is used to receive mails from IOM.</p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Start mailserver
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/mailhog.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl apply --namespace ${EnvId} -f -
        </div></code></pre>

        <h3 id="operations--remove-mailserver">Stop/remove mailserver</h3>
        <p>The following command stops and removes the mailserver.</p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Stop/Remove mailserver
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/mailhog.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl delete --namespace ${EnvId} -f -
        </div></code></pre>

        ${KeepDatabaseDocuStart}
        <h3 id="operations--create-docker-volume">Create local Docker volume</h3>
        <p>The following command creates a local Docker volume to be used to keep database data.</p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Create local Docker volume
docker volume create --name=${EnvId}-pgdata -d local
        </div></code></pre>

        <h3 id="operations--remove-docker-volume">Remove local Docker volume</h3>
        <div class="alert alert-warning" role="alert">
          <strong>Note!</strong>
          <p>If you would like to remove the database data, you just have to remove the database data volume with the following command.</p><br>
          <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Remove Docker volume
docker volume rm ${EnvId}-pgdata
          </div></code></pre>
        </div>

        <h3 id="operations--link-volume-to-db">Link Docker volume to database storage</h3>
        <p>The following command links the local Docker volume to Kubernetes to keep database data.</p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Link Docker volume to database storage
MOUNTPOINT="\"$(docker volume inspect --format='{{.Mountpoint}}' ${EnvId}-pgdata)\"" "${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/postgres-storage.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl apply --namespace ${EnvId} -f -
        </div></code></pre>

        <h3 id="operations--unlink-volume-from-db">Unlink Docker volume from database storage</h3>
        <p>The following command unlinks the local Docker volume from database storage</p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Unlink Docker volume from database storage
MOUNTPOINT="\"$(docker volume inspect --format='{{.Mountpoint}}' ${EnvId}-pgdata)\"" "${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/postgres-storage.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl delete --namespace ${EnvId} -f -            
        </div></code></pre>
        ${KeepDatabaseDocuEnd}

        <h3 id="operations--start-database">Start postgres database</h3>
        <p>The following command starts the database.</p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Start postgres database
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/postgres.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl apply --namespace ${EnvId} -f -
        </div></code></pre>

        <h3 id="operations--remove-database">Stop/remove postgres database</h3>
        <p>The following command stops and removes the database.</p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Stop/Remove postgres database
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/postgres.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl delete --namespace ${EnvId} -f -
        </div></code></pre>

        <h3 id="operations--start-iom">Start IOM</h3>
        <p>The following command starts the IOM application server.</p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Start IOM
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/iom.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl apply --namespace ${EnvId} -f -
        </div></code></pre>

        <h3 id="operations--remove-iom">Stop/remove IOM</h3>
        <p>The following command stops and removes the IOM application server.</p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Stop/Remove IOM
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/iom.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl delete --namespace ${EnvId} -f -
        </div></code></pre>

        <!--
            ############# development process ###############
          -->
        <h2 id="development">Development process</h2>

        <h3 id="development--deployment-gui">Deployment of custom built artifacts using the Wildfly Admin Console</h3>
        <p>
          Using the <a href="http://${HOST_IOM}:${FORWARD_PORT_WILDFLY}/console/index.html#deployments" target="_blank">Wildfly Admin Console (admin:admin)</a> is the easiest way to add or update deployments. The deployment process is simply triggered by Drag & Drop.
        </p><p>
          In difference to <a href="#development--deployment-cli">Deployment of custom built artifacts using scripts</a>, deployments added/updated this way, will not survive a restart of the IOM pod.
        </p>
        <h3 id="development--deployment-cli">Deployment of custom built artifacts using scripts</h3>
        <p>
          The Developer VM has an extended search-path for deployments. The scripts doing the deployment are looking first at directory <samp>/opt/oms/application-dev</samp>, instead of the standard directory <samp>/opt/oms/application</samp>, which contains all the standard deployment artifacts delivered by the Docker image. Hence, if an artifact was found in <samp>/opt/oms/application-dev</samp>, the according standard artifact will be ignored. 
        </p><p>
          All you have to do, is to mount a directory containing your custom built artifacts at <samp>/opt/oms/application-dev</samp>. To do so, you have to:
          <ul>
            <li>set variable <samp>CUSTOM_APPS_DIR</samp> in your config file and make sure, that the <a href="https://blogs.msdn.microsoft.com/stevelasker/2016/06/14/configuring-docker-for-windows-volumes/" target="_blank">directory is shared in Docker Desktop</a>.</li>
            <li>After changing <samp>CUSTOM_APPS_DIR</samp>, the IOM application server needs to be restarted:</li>
            <ol>
              <li><a href="#operations--remove-iom">Stop/remove IOM</a></li>
              <li><a href="#operations--start-iom">Start IOM</a></li>
            </ol>
          </ul>
          Once you have configured your developer VM this way, your custom built artifacts are deployed right at the start of IOM. To update/add deployments in a running developer VM, you have the following possibilities:
        </p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# redeploy omt selectively 
POD_NAME=$(kubectl get pods --namespace ${EnvId} -l app=iom -o jsonpath="{.items[0].metadata.name}")
kubectl exec $POD_NAME --namespace ${EnvId} -- bash -ic redeploy omt

# redeploy all
POD_NAME=$(kubectl get pods --namespace ${EnvId} -l app=iom -o jsonpath="{.items[0].metadata.name}")
kubectl exec $POD_NAME --namespace ${EnvId} -- bash -ic redeploy
        </div></code></pre>
        <p>
          Of course, you can combine both methods of deploying custom built artifacts, to get the best out of both methods. If you set <samp>CUSTOM_APPS_DIR</samp> and make sure the according directory contains your custom built artifacts, your developer VM will always use these artifacts, even right after start of IOM. Additionally you can use <a href="http://${HOST_IOM}:${FORWARD_PORT_WILDFLY}/console/index.html#deployments" target="_blank">Wildfly Admin Console (admin:admin)</a> to update/add deployments during runtime.
        </p>
          
        <h3 id="development--roll-out-mail-templates">Roll out custom mail templates</h3>
        <p>
          The developer VM contains an additional directory <samp>/opt/oms/templates-dev</samp>, which will be used as mount point for custom mail templates. Part of the developer VM is also the script <samp>apply-templates</samp>, which copies the templates from <samp>/opt/oms/templates-dev</samp> to the standard directory <samp>/opt/oms/var/templates</samp>. If you want to roll out custom mail templates in a running developer VM, you have to:
          <ul>
            <li>set variable <samp>CUSTOM_TEMPLATES_DIR</samp> in your config file and make sure, that the <a href="https://blogs.msdn.microsoft.com/stevelasker/2016/06/14/configuring-docker-for-windows-volumes/" target="_blank">directory is shared in Docker Desktop</a>.</li>
            <li>After changing <samp>CUSTOM_TEMPLATES_DIR</samp>, the IOM application server needs to be restarted:</li>
            <ol>
              <li><a href="#operations--remove-iom">Stop/remove IOM</a></li>
              <li><a href="#operations--start-iom">Start IOM</a></li>
            </ol>
          </ul>
          Once you have configured your developer VM this way, you can apply custom mail templates by the following command:
        </p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
POD_NAME=$(kubectl get pods --namespace ${EnvId} -l app=iom -o jsonpath="{.items[0].metadata.name}")
kubectl exec $POD_NAME --namespace ${EnvId} -- bash -ic apply-templates
        </div></code></pre>
        <p>
          If <samp>CUSTOM_TEMPLATES_DIR</samp> is configured, the templates are also copied when starting IOM.
        </p>

        <h3 id="development--roll-out-xsl-templates">Roll out custom xsl templates</h3>
        <p>
          The developer VM contains a directory <samp>/opt/oms/xslt-dev</samp>, which will be used as mount point for custom xsl templates. Part of the developer VM is also the script <samp>apply-xslt</samp>, which copies the templates from <samp>/opt/oms/xslt-dev</samp> to the standard directory <samp>/opt/oms/var/xslt</samp>. If you want to roll out custom xsl templates in a running developer VM, you have to:
          <ul>
            <li>set variable <samp>CUSTOM_XSLT_DIR</samp> in your config file and make sure, that the <a href="https://blogs.msdn.microsoft.com/stevelasker/2016/06/14/configuring-docker-for-windows-volumes/" target="_blank">directory is shared in Docker Desktop</a>.</li>
            <li>After changing <samp>CUSTOM_XSLT_DIR</samp>, the IOM application server has to be restarted:</li>
             <ol>
              <li><a href="#operations--remove-iom">Stop/remove IOM</a></li>
              <li><a href="#operations--start-iom">Start IOM</a></li>
             </ol>
          </ul>
          Once you have configured your developer VM this way, you can apply custom xsl templates by the following command:
        </p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
POD_NAME=$(kubectl get pods --namespace ${EnvId} -l app=iom -o jsonpath="{.items[0].metadata.name}")
kubectl exec $POD_NAME --namespace ${EnvId} -- bash -ic apply-xslt
        </div></code></pre>
        <p>
          if <samp>CUSTOM_XSLT_DIR</samp> is configured, the templates are also copied when starting IOM.
        </p>

        <h3 id="development--apply-sql">Apply sql scripts</h3>
        <p>
          The docker-image defined by <samp>IOM_DBINIT_IMAGE</samp> contains all the necessary tools to apply sql-scripts to the IOM database. Devenv4iom enables you to use these tools as easy as possible. Therefore it provides a Kubernetes job (<samp>apply-sql-job</samp>), that applies sql-file(s) to the IOM database.
        </p><p>
          There are two different modes, that can be used.
          <ul>
            <li>If a directory is passed to the job, all sql-files found in this directory are processed in numerical order, starting with the smallest one. Sub-directories are not scanned for sql-files.</li>
            <li>If a file is passed to the job, only this file will be executed.</li>
          </ul>
          The information about the sql-file or -directory is passed by the variable <samp>SQL_SRC</samp> (absolute name has to be set). This variable is normally not part of the config-file. Instead of it, you should set it on the fly, when running the job. (If you really want, you can add it to the config-file too.) You have to make sure, that the passed <a href="https://blogs.msdn.microsoft.com/stevelasker/2016/06/14/configuring-docker-for-windows-volumes/" target="_blank">directory/file is shared in Docker Desktop</a>. The box below shows an example, that executes all sql-scripts found in <samp>oms.tests/tc_stored_procedures</samp>. Just use another value for <samp>SQL_SRC</samp> to execute the sql-scripts you want.
        </p><p>
          The logs are printed in json format. Verbosity can be controlled by configuration variable <samp>OMS_LOGLEVEL_SCRIPTS</samp>.
        </p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# adapt SQL_SRC to point to the directory/file you want to execute
export SQL_SRC=${IOM_APP_SRC_DIR}/oms.tests/tc_stored_procedures

# start apply-sql-job
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/apply-sql.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl apply --namespace ${EnvId} -f -

# get logs of job
POD_NAME=$(kubectl get pods --namespace ${EnvId} -l job-name=apply-sql-job -o jsonpath="{.items[0].metadata.name}")
kubectl logs $POD_NAME --namespace ${EnvId}

# delete apply-sql-job
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/apply-sql.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl delete --namespace ${EnvId} -f -
        </div></code></pre>
        
        <h3 id="development--apply-dbmigrate">Apply dbmigrate scripts</h3>
        <p>
          To develop and test a single or a couple of sql-scripts (which can be migration scripts too), the developer task <em><a href="#development--apply-sql">Apply sql scripts</a></em> is the first choice. But at some point of development, the dbmigrate process as a whole has to be tested too. The dbmigrate process is somewhat more complex than simply applying sql-scripts from a directory. It first loads stored procedures from directory <samp>stored_procedures</samp> and then it applies the migrations scripts found in directory <samp>migrations</samp>. The order of execution is controlled by the names of sub-directories within <samp>migrations</samp> and the naming of the migration scripts itself (numerically sorted, smallest first).
        </p><p>
          The <samp>IOM_DBINIT_IMAGE</samp> contains a shell script, that is applying the migration scripts, which are delivered along with the docker image. The developer task <em><a href="#development--apply-dbmigrate">Apply dbmigrate scripts</a></em> enables you to use this dbmigrate script along with the migration scripts located at <samp>CUSTOM_DBMIGRATE_DIR</samp>. Hence, if you want to roll out custom dbmigrate scripts, you have to:
          <ul>
            <li>set variable <samp>CUSTOM_DBMIGRATE_DIR</samp> in your config file and make sure, that the <a href="https://blogs.msdn.microsoft.com/stevelasker/2016/06/14/configuring-docker-for-windows-volumes/" target="_blank">directory is shared in Docker Desktop</a>.</li>
          </ul>
        </p><p>
          You can and should have an eye on the logs created by the migration process. These logs are printed in json format. Verbosity can be controlled by configuration variable <samp>OMS_LOGLEVEL_SCRIPTS</samp>.
        </p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# start dbmigrate-job
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/dbmigrate.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl apply --namespace ${EnvId} -f -

# get logs of job
POD_NAME=$(kubectl get pods --namespace ${EnvId} -l job-name=dbmigrate-job -o jsonpath="{.items[0].metadata.name}")
kubectl logs $POD_NAME --namespace ${EnvId}

# delete dbmigrate-job
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/dbmigrate.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl delete --namespace ${EnvId} -f -
        </div></code></pre>
        <p>
          If <samp>CUSTOM_DBMIGRATE_DIR</samp> is configured, the custom dbmigrate scripts are also applied when starting IOM.
        </p>
        
        <h3 id="development--apply-sqlconfig">Apply sql configuration scripts</h3>
        <p>
          Scripts for sql-configuration are simple sql-scripts, which can be easily developed and tested with the help of the developer task <a href="#development--apply-sql">Apply sql scripts</a>. But sql-configuration in CaaS project context is more complex. E.g. the scripts are executed depending on the currently activated environment. In order to enable you to test sql configuration scripts exactly in the same context as in real IOM installation, the developer task <a href="#development--apply-sqlconfig">Apply sql configuration scripts</a> is provided.
        </p><p>
          To be able to roll out complete sql configurations, you have to:
          <ul>
            <li>set variable <samp>CUSTOM_SQLCONF_DIR</samp> in your config file and make sure, that the <a href="https://blogs.msdn.microsoft.com/stevelasker/2016/06/14/configuring-docker-for-windows-volumes/" target="_blank">directory is shared in Docker Desktop</a>.</li>
            <li>set variable <samp>CAAS_ENV_NAME</samp> in your config file to the environment you want to test.</li>
          </ul>
        </p><p>
          You should have an eye on the logs created by the configuration process. These logs are printed in json format. Verbosity can be controlled by configuration variable <samp>OMS_LOGLEVEL_SCRIPTS</samp>.
        </p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# start sqlconfig-job
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/sqlconfig.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl apply --namespace ${EnvId} -f -

# get logs of job
POD_NAME=$(kubectl get pods --namespace ${EnvId} -l job-name=sqlconfig-job -o jsonpath="{.items[0].metadata.name}")
kubectl logs $POD_NAME --namespace ${EnvId}

# delete sqlconfig-job
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/sqlconfig.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl delete --namespace ${EnvId} -f -
        </div></code></pre>
        <p>
          If <samp>CUSTOM_SQLCONFIG_DIR</samp> is configured, the custom sql configuration is also applied when starting IOM.
        </p>

        <h3 id="development--apply-jsonconfig">Apply json configuration scripts</h3>
        <p>
          Json configuration of IOM is not publicly available. There exists no task to support development of single json configuration scripts. Additionally the current implementation of json configuration does not use the concept of environments (configuration variable <samp>CAAS_ENV_NAME</samp>). The current developer task <a href="#development--apply-jsonconfig">Apply json configuration scripts</a> is able to apply complete json configurations exactly in the same context as in a real IOM installation.
        </p><p>
          To be able to roll out json configurations, you have to:
          <ul>
            <li>set variable <samp>CUSTOM_JSONCONF_DIR</samp> in your config file and make sure, that the <a href="https://blogs.msdn.microsoft.com/stevelasker/2016/06/14/configuring-docker-for-windows-volumes/" target="_blank">directory is shared in Docker Desktop</a>.</li>
          </ul>
        </p><p>
          You should have an eye on the logs created by the configuration process. These logs are printed in json format. Verbosity can be controlled by configuration variable <samp>OMS_LOGLEVEL_SCRIPTS</samp>.
        </p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# start jsonconfig-job
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/jsonconfig.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl apply --namespace ${EnvId} -f -

# get logs of job
POD_NAME=$(kubectl get pods --namespace ${EnvId} -l job-name=jsonconfig-job -o jsonpath="{.items[0].metadata.name}")
kubectl logs $POD_NAME --namespace ${EnvId}

# delete jsonconfig-job
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/jsonconfig.yml.template" "${ENV_DIR}/${CONFIG_FILE}" | kubectl delete --namespace ${EnvId} -f -
        </div></code></pre>
        <p>
          If <samp>CUSTOM_JSONCONFIG_DIR</samp> is configured, the custom json configuration is also applied when starting IOM.
        </p>
        
        <h3 id="development--access-emails">Access E-Mails</h3>
        <p>To develop e-mail templates, to test that emails are successfully sent by business processes and in other use cases, it is necessary to access the e-mails. To do so, use the <a href="http://${HOST_IOM}:${FORWARD_PORT_MAILHOG_UI}" target="_blank">Mails (Web-UI)</a> link in the Links navigation bar.</p>

        <h3 id="development--debugging">Debugging</h3>

        <p>In order to debug the application port ${FORWARD_PORT_DEBUG} is available out of the box for Remote Java Debugging. For details see section <a href="#configurations--automatic-port-forwarding">Automatic port forwarding</a>.</p>

        <h3 id="development--testing">Testing</h3>

        <h4 id="provide-geb-properties">Provide geb properties</h4>

        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/geb.properties.template" "${ENV_DIR}/${CONFIG_FILE}" > "${ENV_DIR}/geb.properties"

</div></code></pre>

        <h4 id="provide-ws-properties">Provide ws properties</h4>

        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
"${PROJECT_PATH}/scripts/template_engine.sh" "${PROJECT_PATH}/templates/ws.properties.template" "${ENV_DIR}/${CONFIG_FILE}" > "${ENV_DIR}/ws.properties"

</div></code></pre>

<h4 id="provide-ws-properties">Apply stored procedures</h4>
        <p>
          To apply stored procedures, just use the development task <a href="#development--apply-sql">Apply sql scripts</a> and set <samp>SQL_SRC</samp> to the directory containing the stored procedures, required for testing.
        </p>
        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
export SQL_SRC=${IOM_APP_SRC_DIR}/oms.tests/tc_stored_procedures
# now continue as described in "Apply sql scripts"
</div></code></pre>

          <h4 id="run-tests">Useful patterns to run single tests or a group of tests</h4>
          <p> To run a single test, just use the the feature name or a substring of it. E.g:</p>

          <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Go to the oms.tests directory in your oms source directory
cd ${IOM_APP_SRC_DIR}/oms.tests

# Run a single geb test
./gradlew gebTest -Pgeb.propFile=${ENV_DIR}/geb.properties --tests="IOM: Role Assignment Management: admin_Oms_1 lists users for role-assignment"

# Run a group of geb tests
./gradlew gebTest -Pgeb.propFile=${ENV_DIR}/geb.properties --tests="*admin_Oms_1 lists users for role-assignment*"

</div></code></pre>

          <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Go to the oms.tests directory in your oms source directory
cd ${IOM_APP_SRC_DIR}/oms.tests

# Run a single ws test
./gradlew wsTest -Pws.propFile=${ENV_DIR}/ws.properties --tests="IOM-7421-1: OrderService v1.2: Create an order with one position and billing address == shipping address"

# Run a group of ws tests
./gradlew wsTest -Pws.propFile=${ENV_DIR}/ws.properties --tests="*OrderService v1.2: Create an order with one position and billing address*"

</div></code></pre>

        <h4 id="run-all-tests">All tests of a specification</h4>
        <p> To run all tests of a specification, just use the the name of the specification. E.g:</p>

          <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Go to the oms.tests directory in your oms source directory
cd ${IOM_APP_SRC_DIR}/oms.tests

# Run all tests of a geb test specification
./gradlew gebTest -Pgeb.propFile=${ENV_DIR}/geb.properties --tests="*RoleAssignmentManagementListUsersSpec*"

# Run all tests of a ws test specification
./gradlew wsTest -Pws.propFile=${ENV_DIR}/ws.properties --tests="*ReverseServiceSpec*"

</div></code></pre>

        <h4 id="run-test-group">All tests of a group of specifications (e.g. user management, role management)</h4>
        <p> To run all tests of a group of specifications, just use the name of the uses package. E.g:</p>

          <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Go to the oms.tests directory in your oms source directory
cd ${IOM_APP_SRC_DIR}/oms.tests

# Run all tests of a specification group
./gradlew gebTest -Pgeb.propFile=${ENV_DIR}/geb.properties --tests="*com.intershop.oms.tests.roleassignment*"

</div></code></pre>

        <h4 id="run-test-group">Run soap tests</h4>
        <p> To run all soap tests just use the following code:</p>

  <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# Go to the oms.soap.tests directory in your oms source directory
cd ${IOM_APP_SRC_DIR}/oms.soap.tests

# Run all soap tests
mvn -Dhost=${HOST_IOM}:${FORWARD_PORT_IOM} clean test

</div></code></pre>

        <h2 id="database">Database</h2>

<!--
        <h3 id="database--init">Initialize the database</h3>

        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
cd ${PROJECT_PATH}<span class="btn btn-primary btn-xs alias-toggle" style="float:right" aria-expanded="false" data-target=".database--init-aliases" data-toggle="collapse" title="Show aliases"><i class="fa fa-plus"></i></span>
${VAGRANT_SSH}

# Initialize the postgres database container<span class="collapse database--init-aliases"># alias ${DOCKER_DATABASE_INIT_ALIAS}="${DOCKER_DATABASE_INIT}"</span>
${DOCKER_DATABASE_INIT_ALIAS}
        </div></code></pre>


cd ${PROJECT_PATH}<span class="btn btn-primary btn-xs alias-toggle" style="float:right" aria-expanded="false" data-target=".database--migrate-aliases" data-toggle="collapse" title="Show aliases"><i class="fa fa-plus"></i></span>
${VAGRANT_SSH}

# Migrate the postgres database container<span class="collapse database--migrate-aliases"># alias ${DOCKER_DATABASE_MIGRATE_ALIAS}="${DOCKER_DATABASE_MIGRATE}"</span>
${DOCKER_DATABASE_MIGRATE_ALIAS}
        </div></code></pre>

        <h3 id="database--create-dump">Create a database dump</h3>

        <p>Sometimes it is very useful to create a database dump (e.g. for setting up a second environment or for giving it to other developers). Following command creates a timestamped dump in your local postgres/dumps directory.</p>

        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
cd ${PROJECT_PATH}<span class="btn btn-primary btn-xs alias-toggle" style="float:right" aria-expanded="false" data-target=".database--create-dump-aliases" data-toggle="collapse" title="Show aliases"><i class="fa fa-plus"></i></span>
${VAGRANT_SSH}

# Create a timestamped datbase dump in your local postgres/dumps directory<span class="collapse database--create-dump-aliases"># alias ${DOCKER_DATABASE_CREATE_DUMP_ALIAS}="${DOCKER_DATABASE_CREATE_DUMP}"</span>
${DOCKER_DATABASE_CREATE_DUMP_ALIAS}
        </div></code></pre>

        <h3 id="database--open-psql-terminal">Open psql terminal</h3>

        <p>Following command opens a psql terminal.</p>

        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
cd ${PROJECT_PATH}<span class="btn btn-primary btn-xs alias-toggle" style="float:right" aria-expanded="false" data-target=".database--open-psql-terminal-aliases" data-toggle="collapse" title="Show aliases"><i class="fa fa-plus"></i></span>
${VAGRANT_SSH}

# Connect to the IOM db container via psql<span class="collapse database--open-psql-terminal-aliases"># alias ${DOCKER_DATABASE_OPEN_PSQL_TERMINAL_ALIAS}="${DOCKER_DATABASE_OPEN_PSQL_TERMINAL}"</span>
${DOCKER_DATABASE_OPEN_PSQL_TERMINAL_ALIAS}

# Enter the password for user ${DB_USER}: ${DB_PASSWORD}
        </div></code></pre>

-->

        <h2 id="kubernetes">Kubernetes</h2>
        <h3 id="kubernetes--useful">Useful kubernetes commands</h3>

        <pre class="prettyprint lang-bash"><code><div class="col-xs-12">
# List all Deployments, Pods, replicasets, services, namespaces
kubectl get deployments --namespace ${EnvId}
kubectl get pods --namespace ${EnvId}
kubectl get replicasets --namespace ${EnvId}
kubectl get services --namespace ${EnvId}
kubectl get namespaces

# Query pod name
POD_NAME=$(kubectl get pods --namespace ${EnvId} -l app=iom -o jsonpath="{.items[0].metadata.name}")

# Logs for initContainer
kubectl logs --namespace ${EnvId} "$POD_NAME" -c dbaccount
kubectl logs --namespace ${EnvId} "$POD_NAME" -c dbinit
kubectl logs --namespace ${EnvId} "$POD_NAME" -c dbinit | jq 'select((.level == "INFO") and (.processName == "load_dbmigrate.sh"))'

# Logs for container

# Error
mkdir -p "${ENV_DIR}/logs" && kubectl logs --namespace ${EnvId} "$POD_NAME" -c iom | sed -n '/^{/,/}$/ p' | jq 'select(.level == "ERROR") | .timestamp, .message, .stackTrace'| sed 's/\\n/\n/g' | sed 's/\\t/\t/g' > "${ENV_DIR}/logs/errors.txt"

# Access
mkdir -p "${ENV_DIR}/logs" && kubectl logs --namespace ${EnvId} "$POD_NAME" -c iom | sed -n '/^{/,/}$/ p' | jq 'select(.eventSource == "web-access") | .dateTime, .responseCode, .requestLine' | sed 's/\\n/\n/g' | sed 's/\\t/\t/g' > "${ENV_DIR}/logs/web-access-1.txt"

mkdir -p "${ENV_DIR}/logs" && kubectl logs --namespace ${EnvId} "$POD_NAME" -c iom | sed -n '/^{/,/}$/ p' | jq 'select(.eventSource == "web-access" and .requestLine != "GET /monitoring/services/health/status HTTP/1.1") | .dateTime, .responseCode, .requestLine'| sed 's/\\n/\n/g' | sed 's/\\t/\t/g' > "${ENV_DIR}/logs/web-access-2.txt"

# Warnings
mkdir -p "${ENV_DIR}/logs" && kubectl logs --namespace ${EnvId} "$POD_NAME" -c iom | sed -n '/^{/,/}$/ p' | jq 'select(.level == "ERROR" or .level == "WARN") | .timestamp, .level, .message, .stackTrace' | sed 's/\\n/\n/g' | sed 's/\\t/\t/g' > "${ENV_DIR}/logs/warnings.txt"

# Login into the IOM Pod
kubectl exec --namespace ${EnvId} "$POD_NAME" -it bash

# Show important information of the pods, deployments, services
kubectl describe --namespace ${EnvId} pod "$POD_NAME"
kubectl describe --namespace ${EnvId} deployment iom
kubectl describe --namespace ${EnvId} service iom-service
        </div></code></pre>

        <h2 id="troubleshooting">Troubleshooting</h2>

        <h3 id="troubleshooting--shared-drives">Shared Drives</h3>

        After resetting your password you can have some problems with your shared drives. In those cases use the Settings > Shared Drives > Reset credentials

      <br><br>

      </div> <!-- /container -->


      <!-- Bootstrap core JavaScript
      ================================================== -->
      <!-- Placed at the end of the document so the pages load faster -->
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
      <script>window.jQuery || document.write('<script src="../../assets/js/vendor/jquery.min.js"><\/script>')</script>

      <script>

          // toogle icon and title
          function toggleAliasButton(e) {

              var icon = $(e.target);
              var button = icon.parent();

              // if the button was clicked instead of the icon
              if($(e.target).children('i').length) {
                  button = $(e.target);
                  icon = button.find('i');
              }

              icon.toggleClass('fa-plus');
              icon.toggleClass('fa-minus');

              var title = 'Show aliases';

              if( icon.hasClass('fa-minus')){
                 title = 'Hide aliases';
              }

              button.attr('title', title);
          }
          $('.alias-toggle').on('click', toggleAliasButton);

      </script>

      <!-- Latest compiled and minified JavaScript -->
      <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    </body>
</html>
